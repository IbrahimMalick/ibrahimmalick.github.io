<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive AI Course</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <header>
        <h1>Interactive AI Course</h1>
        <nav>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#module1">Module 1: Search and Problem Solving</a></li>
                <li><a href="#module2">Module 2: Propositional Logic</a></li>
                <li><a href="#module3">Module 3: Machine Learning</a></li>
                <li><a href="#assessment">Assessment</a></li>
            </ul>
        </nav>
    </header>
    
    <main>
        <section id="overview">
            <h2>Course Overview</h2>
            <p>Welcome to our comprehensive interactive course on Artificial Intelligence fundamentals. This course covers key concepts in search algorithms, propositional logic, and machine learning through interactive lessons and visualizations.</p>
            
            <p>This interactive course is designed to provide both theoretical understanding and practical application of fundamental AI concepts. The course is structured into three main modules:</p>
            
            <ol>
                <li><strong>Search and Problem Solving</strong> - Learn how to formulate search problems and understand different search algorithms</li>
                <li><strong>Propositional Logic and Knowledge-Based Agents</strong> - Explore logical reasoning and knowledge representation</li>
                <li><strong>Introduction to Machine Learning</strong> - Understand supervised and unsupervised learning approaches and neural networks</li>
            </ol>
            
            <p>Each module contains interactive visualizations, step-by-step explanations, and exercises to reinforce your learning.</p>
        </section>
        
        <section id="module1">
            <h2>Module 1: Search and Problem Solving</h2>
            <p>In this module, we explore how AI systems search for solutions to problems.</p>
            
            <h3>Lesson 1.1: Formulating Search Problems</h3>
            <p>Search problems form the foundation of many artificial intelligence applications. To properly formulate a search problem, we need to define several key components:</p>
            <ul>
                <li><strong>State Space</strong>: All possible configurations in our problem domain</li>
                <li><strong>Initial State</strong>: Our starting point</li>
                <li><strong>Goal State(s)</strong>: The desired outcomes we're searching for</li>
                <li><strong>Actions</strong>: Operations that transform one state into another</li>
                <li><strong>Transition Model</strong>: Defines how actions change states</li>
                <li><strong>Action Cost Function</strong>: Assigns a numeric cost to each action</li>
            </ul>
            <p>Understanding these components is crucial for applying search algorithms effectively.</p>
            
            <h3>Lesson 1.2: Search Algorithms</h3>
            <p>Search algorithms systematically explore the state space to find paths from the initial state to a goal state. We focus on two important algorithms:</p>
            
            <h4>Breadth-First Search (BFS)</h4>
            <ul>
                <li>Explores nodes level by level</li>
                <li>Complete and optimal (with uniform costs)</li>
                <li>Memory-intensive for large problems</li>
            </ul>
            
            <h4>Greedy Best-First Search (GBFS)</h4>
            <ul>
                <li>Uses a heuristic to prioritize promising nodes</li>
                <li>Often faster but not guaranteed to be optimal</li>
                <li>Can get stuck in loops or dead ends</li>
            </ul>
            
            <div class="chart-container">
                <canvas id="bfsVsGbfsChart"></canvas>
            </div>
            
            <h3>Lesson 1.3: Tree Search vs Graph Search</h3>
            <p>These approaches differ in how they manage the frontier of nodes to be explored:</p>
            
            <h4>Tree Search</h4>
            <ul>
                <li>Treats the search space as a tree</li>
                <li>May revisit the same states through different paths</li>
                <li>Lower memory requirements but potentially inefficient</li>
            </ul>
            
            <h4>Graph Search</h4>
            <ul>
                <li>Keeps track of visited states to avoid redundant exploration</li>
                <li>More efficient for problems with cycles or multiple paths</li>
                <li>Higher memory requirements</li>
            </ul>
            
            <div class="chart-container">
                <canvas id="treeVsGraphChart"></canvas>
            </div>
            
            <h3>Module 1 Exercises</h3>
            <p>Test your understanding with these exercises:</p>
            <ol>
                <li><strong>Formulating Search Problems</strong>: Identify state space, initial state, goal state, actions, and cost functions for various scenarios.</li>
                <li><strong>Search Algorithm Analysis</strong>: Compare BFS and GBFS on different graph structures.</li>
                <li><strong>Tree vs Graph Search Comparison</strong>: Analyze efficiency differences between these approaches.</li>
                <li><strong>Implementation Challenge</strong>: Write pseudocode for search algorithms and design heuristics.</li>
            </ol>
            <a href="modules/module1_exercises.html" class="button">Go to Module 1 Exercises</a>
        </section>
        
        <section id="module2">
            <h2>Module 2: Propositional Logic and Knowledge-Based Agents</h2>
            <p>This module covers how AI systems represent and reason with knowledge.</p>
            
            <h3>Lesson 2.1: Propositional Logic Fundamentals</h3>
            <p>Propositional logic provides a formal framework for representing statements that can be either true or false:</p>
            <ul>
                <li><strong>Propositional Symbols</strong>: Basic building blocks representing simple statements</li>
                <li><strong>Logical Connectives</strong>: Operators like ¬ (not), ∧ (and), ∨ (or), → (implies), ↔ (if and only if)</li>
                <li><strong>Truth Tables</strong>: Systematic way to display truth values of compound propositions</li>
                <li><strong>Normal Forms</strong>: Standardized ways of writing logical expressions (CNF, DNF)</li>
            </ul>
            
            <h3>Lesson 2.2: Knowledge-Based Agents</h3>
            <p>Knowledge-based agents use a knowledge base to reason and act:</p>
            <ul>
                <li><strong>Knowledge Base (KB)</strong>: Set of sentences representing facts about the world</li>
                <li><strong>TELL Operation</strong>: Adds new information to the knowledge base</li>
                <li><strong>ASK Operation</strong>: Queries the knowledge base to determine if a sentence is entailed</li>
                <li><strong>Inference Engine</strong>: Derives new sentences from existing ones in the KB</li>
            </ul>
            
            <h3>Lesson 2.3: Inference in Propositional Logic</h3>
            <p>Inference allows us to derive new knowledge from existing knowledge:</p>
            <ul>
                <li><strong>Sound Inference</strong>: Only derives sentences that are entailed by the knowledge base</li>
                <li><strong>Complete Inference</strong>: Can derive all sentences that are entailed by the knowledge base</li>
                <li><strong>Inference Methods</strong>: Truth tables, forward chaining, backward chaining, resolution</li>
                <li><strong>Inference Rules</strong>: Modus Ponens, Modus Tollens, Resolution, etc.</li>
            </ul>
            
            <div class="chart-container">
                <canvas id="truthTableChart"></canvas>
            </div>
            
            <h3>Lesson 2.4: Satisfiability Algorithms</h3>
            <p>Satisfiability (SAT) is a fundamental problem in propositional logic:</p>
            
            <h4>DPLL Algorithm</h4>
            <ul>
                <li>Complete, backtracking-based algorithm</li>
                <li>Uses unit propagation and pure literal elimination</li>
                <li>Systematically explores possible assignments</li>
                <li>Can prove unsatisfiability</li>
            </ul>
            
            <h4>WalkSAT Algorithm</h4>
            <ul>
                <li>Incomplete, local search algorithm</li>
                <li>Starts with random assignment and iteratively improves</li>
                <li>Often faster for finding satisfying assignments</li>
                <li>Cannot prove unsatisfiability</li>
            </ul>
            
            <div class="chart-container">
                <canvas id="dpllVsWalkSATChart"></canvas>
            </div>
            
            <h3>Module 2 Exercises</h3>
            <p>Test your understanding with these exercises:</p>
            <ol>
                <li><strong>Propositional Logic Translation</strong>: Convert English statements to propositional logic.</li>
                <li><strong>Truth Table Construction</strong>: Build truth tables for complex expressions.</li>
                <li><strong>Knowledge Base Operations</strong>: Practice TELL and ASK operations.</li>
                <li><strong>Inference Rule Application</strong>: Apply inference rules to derive new sentences.</li>
                <li><strong>Algorithm Tracing</strong>: Trace the execution of DPLL and WalkSAT algorithms.</li>
            </ol>
            <a href="modules/module2_exercises.html" class="button">Go to Module 2 Exercises</a>
        </section>
        
        <section id="module3">
            <h2>Module 3: Introduction to Machine Learning</h2>
            <p>This module introduces fundamental concepts in machine learning.</p>
            
            <h3>Lesson 3.1: Supervised vs Unsupervised Learning</h3>
            <p>Machine learning enables computers to learn from experience:</p>
            
            <h4>Supervised Learning</h4>
            <ul>
                <li>Learns from labeled training data</li>
                <li>Maps inputs to known outputs</li>
                <li>Applications: Classification, regression</li>
                <li>Examples: Linear regression, decision trees, neural networks</li>
            </ul>
            
            <h4>Unsupervised Learning</h4>
            <ul>
                <li>Learns from unlabeled data</li>
                <li>Discovers patterns or structures</li>
                <li>Applications: Clustering, dimensionality reduction</li>
                <li>Examples: K-means, PCA, autoencoders</li>
            </ul>
            
            <div class="chart-container">
                <canvas id="supervisedVsUnsupervisedChart"></canvas>
            </div>
            
            <h3>Lesson 3.2: Neural Networks Basics</h3>
            <p>Neural networks are computational models inspired by the human brain:</p>
            <ul>
                <li><strong>Neurons</strong>: Basic computational units that process inputs</li>
                <li><strong>Weights and Biases</strong>: Parameters that the network learns</li>
                <li><strong>Activation Functions</strong>: Introduce non-linearity (ReLU, sigmoid, tanh)</li>
                <li><strong>Layers</strong>: Input layer, hidden layers, output layer</li>
                <li><strong>Learning Process</strong>: Forward propagation, loss calculation, backpropagation</li>
            </ul>
            
            <h4>Convolutional Neural Networks (CNNs)</h4>
            <ul>
                <li>Specialized for processing grid-like data (e.g., images)</li>
                <li>Key components: Convolutional layers, pooling layers, fully connected layers</li>
                <li>Filter placement: Filters slide across the input to detect features</li>
            </ul>
            
            <div class="chart-container">
                <canvas id="neuralNetworkChart"></canvas>
            </div>
            
            <div class="chart-container">
                <canvas id="cnnFilterChart"></canvas>
            </div>
            
            <h3>Module 3 Exercises</h3>
            <p>Test your understanding with these exercises:</p>
            <ol>
                <li><strong>Learning Paradigm Classification</strong>: Identify appropriate learning approaches for different scenarios.</li>
                <li><strong>Neural Network Components</strong>: Explain the purpose and function of neural network elements.</li>
                <li><strong>Forward Propagation Calculation</strong>: Perform step-by-step calculations through a simple neural network.</li>
                <li><strong>CNN Filter Placement</strong>: Calculate filter positions for various input and filter configurations.</li>
                <li><strong>Machine Learning Challenges</strong>: Address overfitting, ethical considerations, and implementation strategies.</li>
            </ol>
            <a href="modules/module3_exercises.html" class="button">Go to Module 3 Exercises</a>
        </section>
        
        <section id="assessment">
            <h2>Comprehensive Assessment</h2>
            <p>Test your understanding of all course concepts with these questions:</p>
            
            <div class="quiz-container">
                <div class="quiz-question">
                    <h3>Question 1</h3>
                    <p>What is the key difference between BFS and GBFS?</p>
                    <div class="answer">
                        <p>BFS explores nodes level by level, while GBFS uses a heuristic to prioritize nodes that appear closer to the goal.</p>
                    </div>
                </div>
                
                <div class="quiz-question">
                    <h3>Question 2</h3>
                    <p>Why might graph search be preferred over tree search?</p>
                    <div class="answer">
                        <p>Graph search avoids redundant exploration of states by keeping track of visited nodes, making it more efficient for problems with cycles or multiple paths to the same state.</p>
                    </div>
                </div>
                
                <div class="quiz-question">
                    <h3>Question 3</h3>
                    <p>What makes an inference procedure sound?</p>
                    <div class="answer">
                        <p>An inference procedure is sound if it only derives sentences that are entailed by the knowledge base, ensuring that false conclusions are never derived from true premises.</p>
                    </div>
                </div>
                
                <div class="quiz-question">
                    <h3>Question 4</h3>
                    <p>What is the main difference between DPLL and WalkSAT?</p>
                    <div class="answer">
                        <p>DPLL is a complete, systematic algorithm that can prove unsatisfiability, while WalkSAT is an incomplete, local search algorithm that can quickly find satisfying assignments but cannot prove unsatisfiability.</p>
                    </div>
                </div>
                
                <div class="quiz-question">
                    <h3>Question 5</h3>
                    <p>How does supervised learning differ from unsupervised learning?</p>
                    <div class="answer">
                        <p>Supervised learning uses labeled data to learn a mapping from inputs to known outputs, while unsupervised learning discovers patterns in unlabeled data without predefined outputs.</p>
                    </div>
                </div>
                
                <div class="quiz-question">
                    <h3>Question 6</h3>
                    <p>What is the purpose of activation functions in neural networks?</p>
                    <div class="answer">
                        <p>Activation functions introduce non-linearity into neural networks, allowing them to learn complex patterns and relationships that couldn't be captured with linear functions alone.</p>
                    </div>
                </div>
            </div>
        </section>
    </main>
    
    <footer>
        <p>&copy; 2025 Interactive AI Course. All rights reserved.</p>
    </footer>
    
    <script src="js/charts.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
